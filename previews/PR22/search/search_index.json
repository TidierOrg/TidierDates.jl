{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#tidierdatesjl","title":"TidierDates.jl","text":"<p>TidierDates.jl is a package dedicated to handling dates and times. It focuses on functionality within the <code>lubridate</code> R package. This package was designed to work with <code>TidierData.jl</code> but can also work independently.</p> <p>This package re-exports <code>Dates.jl</code>.</p> <p>In addition, this package includes:</p> <ul> <li><code>ymd()</code>, <code>ymd_hms()</code>, <code>ymd_h()</code>, <code>ymd_hm()</code></li> <li><code>dmy()</code>, <code>dmy_hms()</code>, <code>dmy_h()</code>, <code>dmy_hm()</code></li> <li><code>mdy()</code>, <code>mdy_hms()</code>, <code>mdy_h()</code>, <code>mdy_hm()</code></li> <li><code>floor_date()</code></li> <li><code>round_date()</code></li> <li><code>timediff()</code></li> <li><code>now()</code>, <code>today()</code></li> <li><code>am()</code>, <code>pm()</code></li> <li><code>leap_year()</code></li> <li><code>days_in_month()</code></li> </ul> <p>English, Spanish, Portuguese and French months and abbreviations are supported.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#index","title":"Index","text":"<ul> <li><code>TidierDates.am</code></li> <li><code>TidierDates.days_in_month</code></li> <li><code>TidierDates.difftime</code></li> <li><code>TidierDates.dmy</code></li> <li><code>TidierDates.dmy_h</code></li> <li><code>TidierDates.dmy_hm</code></li> <li><code>TidierDates.dmy_hms</code></li> <li><code>TidierDates.floor_date</code></li> <li><code>TidierDates.hm</code></li> <li><code>TidierDates.hms</code></li> <li><code>TidierDates.leap_year</code></li> <li><code>TidierDates.mdy</code></li> <li><code>TidierDates.mdy_h</code></li> <li><code>TidierDates.mdy_hm</code></li> <li><code>TidierDates.mdy_hms</code></li> <li><code>TidierDates.now</code></li> <li><code>TidierDates.pm</code></li> <li><code>TidierDates.round_date</code></li> <li><code>TidierDates.today</code></li> <li><code>TidierDates.ymd</code></li> <li><code>TidierDates.ymd_h</code></li> <li><code>TidierDates.ymd_hm</code></li> <li><code>TidierDates.ymd_hms</code></li> </ul>"},{"location":"reference/#reference-exported-functions","title":"Reference - Exported functions","text":"<p># <code>TidierDates.am</code> \u2014 Method.</p> <pre><code>am(dt::DateTime)::Bool\n</code></pre> <p>Checks if the time is in the morning.</p> <p>Arguments</p> <p><code>dt</code>: A DateTime object</p> <p>Returns</p> <p>A boolean indicating whether the time is in the morning.</p> <p>Examples</p> <pre><code>julia&gt; am(DateTime(2023, 6, 15, 9, 30, 0))\ntrue\n\njulia&gt; am(DateTime(2023, 6, 15, 8, 30, 0))\ntrue\n</code></pre> <p>source</p> <p># <code>TidierDates.days_in_month</code> \u2014 Method.</p> <pre><code>days_in_month(date::Date)::Int\n</code></pre> <p>Returns the number of days in the month.</p> <p>Arguments</p> <p><code>date</code>: A Date object</p> <p>Returns</p> <p>An integer representing the number of days in the month.</p> <p>Examples</p> <pre><code>julia&gt; days_in_month(Date(2023, 6, 15))\n30\n\njulia&gt; days_in_month(Date(2020, 2, 29))\n29\n\njulia&gt; days_in_month(Date(2019, 2, 28))\n28\n\njulia&gt; days_in_month(Date(2016, 2, 3))\n29\n</code></pre> <p>source</p> <p># <code>TidierDates.difftime</code> \u2014 Method.</p> <p>difftime(time1::Union{DateTime, Missing}, time2::Union{DateTime, Missing}, units::AbstractString)</p> <p>Calculate the difference between two times in the specified units.</p> <p>Arguments</p> <p><code>time1</code>: A DateTime object (can contain missing values in a DataFrame). <code>time2</code>: A DateTime object (can contain missing values in a DataFrame). <code>units</code>: A string specifying the units to use when calculating the difference between the two times. The units can be one of the following: \"seconds\", \"minutes\", \"hours\", \"days\", \"weeks\".</p> <p>Returns</p> <p>The difference between the two times in the specified units. If either of the inputs is missing, the function returns a missing value.</p> <p>Examples</p> <pre><code>julia&gt; time1 = DateTime(2023, 6, 15, 9, 30, 0)\n2023-06-15T09:30:00\n\njulia&gt; time2 = DateTime(2023, 6, 15, 8, 30, 0)\n2023-06-15T08:30:00\n\njulia&gt; difftime(time1, time2, \"hours\")\n1.0\n\njulia&gt; difftime(time1, time2, \"minutes\")\n60.0\n\njulia&gt; difftime(time1, missing, \"hours\")\nmissing\n</code></pre> <p>source</p> <p># <code>TidierDates.dmy</code> \u2014 Method.</p> <pre><code>dmy(date_string::Union{AbstractString, Missing})\n</code></pre> <p>Converts a date string in various formats (like \"ddmmyyyy\", \"day month, year\", \"d/m/y\", \"d-m-y\" or \"day of month, year\") to a Julia Date object. The function is able to handle missing values and returns missing for missing inputs.</p> <p>Arguments</p> <p><code>date_string</code>::Union{AbstractString, Missing}: The date string to be converted to a Date object.</p> <p>Examples</p> <pre><code>julia&gt; dmy(\"03122020\")\n2020-12-03\n\njulia&gt; dmy(\"3 December, 2020\")\n2020-12-03\n\njulia&gt; dmy(\"23/12/2020\")\n2020-12-23\n\njulia&gt; dmy(\"3-12-2020\")\n2020-12-03\n\njulia&gt; dmy(\"3rd of December, 2020\")\n2020-12-03\n\njulia&gt; dmy(\"3rd of December, 2020\")\n2020-12-03\n\njulia&gt; dmy(missing)\nmissing\n\njulia&gt; dmy(\"20 DICIEMBRE 2020\") # Spanish\n2020-12-20\n\njulia&gt; dmy(\"21 MAR\u00c7O 2014\") # Portuguese \n2014-03-21\n</code></pre> <p>source</p> <p># <code>TidierDates.dmy_h</code> \u2014 Method.</p> <pre><code>dmy_h(datetime_string::Union{AbstractString, Missing})::DateTime\n</code></pre> <p>Converts a date and time string in the format \"DD-MM-YYYY HH\" to a DateTime object.</p> <p>Arguments</p> <p><code>datetime_string</code>: A string containing a datetime representation (can contain missing values in a DataFrame).</p> <p>Returns</p> <p>A DateTime object constructed from the parsed day, month, year, and hour values from the input string, if all can be parsed successfully. Returns a missing value if the input is missing or if the datetime information cannot be parsed from the string.  </p> <p>Examples</p> <pre><code>julia&gt; dmy_h(\"01/01/2020 4PM\")\n2020-01-01T16:00:00\n\njulia&gt; dmy_h(\"01-01-2020 16hrs\")\n2020-01-01T16:00:00\n\njulia&gt; dmy_h(missing)\nmissing\n</code></pre> <p>source</p> <p># <code>TidierDates.dmy_hm</code> \u2014 Method.</p> <pre><code>dmy_hm(datetime_string::Union{AbstractString, Missing})::DateTime\n</code></pre> <p>Converts a date and time string in the format \"DD-MM-YYYY HH:MM\" to a DateTime object.</p> <p>Arguments</p> <p><code>datetime_string</code>: A string containing a datetime representation (can contain missing values in a DataFrame).</p> <p>Returns</p> <p>A DateTime object constructed from the parsed day, month, year, hour, and minute values from the input string, if all can be parsed successfully. Returns a missing value if the input is missing or if the datetime information cannot be parsed from the string.</p> <p>Examples</p> <pre><code>julia&gt; dmy_hm(\"01/01/2020 4:30PM\")\n2020-01-01T16:30:00\n\njulia&gt; dmy_hm(\"01/01/2020 4:30 a\")\n2020-01-01T04:30:00\n\njulia&gt; dmy_hm(missing)\nmissing\n</code></pre> <p>source</p> <p># <code>TidierDates.dmy_hms</code> \u2014 Method.</p> <pre><code>dmy_hms(datetime_string::Union{AbstractString, Missing})\n</code></pre> <p>Convert a string with \"Day-Month-Year Hour:Minute:Second\" format to a DateTime object.</p> <p>Arguments</p> <p><code>datetime_string</code>: A string (can contain missing values in a DataFrame).</p> <p>Returns</p> <p>A DateTime object converted from the string. If the input is missing or the string format is incorrect, the function returns a missing value.</p> <p>Examples</p> <pre><code>julia&gt; dmy_hms(\"15-06-2023 09:30:00\")\n2023-06-15T09:30:00\n\njulia&gt; dmy_hms(\"15/06/2023 09:30:00pm\")\n2023-06-15T21:30:00\n\njulia&gt; dmy_hms(\"15 jan 2023 09:30:00 p\")\n2023-01-15T21:30:00\n\njulia&gt; dmy_hms(missing)\nmissing\n</code></pre> <p>source</p> <p># <code>TidierDates.floor_date</code> \u2014 Method.</p> <pre><code>floor_date(dt::Union{DateTime, Missing}, unit::String)\n</code></pre> <p>Round down a DateTime object to the nearest specified unit.</p> <p>Arguments</p> <p><code>dt</code>: A DateTime object (can contain missing values in a DataFrame). <code>unit</code>: A string specifying the units to use for rounding down. The units can be one of the following: \"year\", \"quarter\", \"month\", \"week\", \"day\", \"hour\", \"minute\".</p> <p>Returns</p> <p>The DateTime object rounded down to the nearest specified unit. If the input is missing, the function returns a missing value.</p> <p>When using the \"week\" unit, Sunday is considered the first day of the week, and if the date is already a Sunday, it is returned as is.</p> <p>Examples</p> <pre><code>julia&gt; dt = DateTime(2023, 6, 15, 9, 45)\n2023-06-15T09:45:00\n\njulia&gt; floor_date(dt, \"hour\")\n2023-06-15T09:00:00\n\njulia&gt; floor_date(dt, \"day\")\n2023-06-15T00:00:00\n\njulia&gt; floor_date(dt, \"week\")\n2023-06-11T00:00:00\n\njulia&gt; floor_date(dt, \"quarter\")\n2023-04-01T00:00:00\n\njulia&gt; floor_date(missing, \"day\")\nmissing\n</code></pre> <p>source</p> <p># <code>TidierDates.hm</code> \u2014 Method.</p> <pre><code>hm(time_string::Union{AbstractString, Missing})::Time\n</code></pre> <p>Converts a time string in the format \"HH:MM\" to a Time object.</p> <p>Arguments</p> <p><code>time_string</code>: A string containing a time representation. </p> <p>Returns</p> <p>A Time object constructed from the parsed hour and minute values from the input string, if all can be parsed successfully. Returns a missing value if the input is missing or if the time information cannot be parsed from the string.</p> <p>Examples</p> <pre><code>julia&gt; hm(\"09:30\")\n09:30:00\n\njulia&gt; hm(\"12:60\")\nmissing\n</code></pre> <p>source</p> <p># <code>TidierDates.hms</code> \u2014 Method.</p> <pre><code>hms(time_string::Union{String, Missing})\n</code></pre> <p>Converts a time string in the format \"HH:MM:SS\" to a Time object. If the input string does not match this format or cannot be converted, an error is thrown.</p> <p>Arguments</p> <p><code>time_string</code>: A string or missing value representing a time. The string should be in the format \"HH:MM:SS\". Returns A Time object representing the input time string.</p> <p>Examples</p> <pre><code>julia&gt; hms(\"12:34:56\")\n12:34:56\n\njulia&gt; hms(missing)\nmissing\n</code></pre> <p>source</p> <p># <code>TidierDates.leap_year</code> \u2014 Method.</p> <pre><code>leap_year(date::Date)::Bool\nleap_year(date::Int)::Bool\n</code></pre> <p>Checks if the year is a leap year.</p> <p>Arguments</p> <p><code>date</code>: A Date object or an integer representing the year.</p> <p>Returns</p> <p>A boolean indicating whether the year is a leap year.</p> <p>Examples</p> <pre><code>julia&gt; leap_year(Date(2023, 6, 15))\nfalse\n\njulia&gt; leap_year(2020)\ntrue\n</code></pre> <p>source</p> <p># <code>TidierDates.mdy</code> \u2014 Method.</p> <pre><code>mdy(date_string::Union{AbstractString, Missing})\n</code></pre> <p>Converts a date string in various formats (like \"mmddyyyy\", \"month day, year\", \"m/d/y\", or \"m-d-y\") to a Julia Date object. The function is able to handle missing values and returns missing for missing inputs.</p> <p>Arguments</p> <p><code>date_string</code>::Union{AbstractString, Missing}: The date string to be converted to a Date object.</p> <p>Examples</p> <pre><code>julia&gt; mdy(\"12032020\")\n2020-12-03\n\njulia&gt; mdy(\"December 3, 2020\")\n2020-12-03\n\njulia&gt; mdy(\"12/03/2020\")\n2020-12-03\n\njulia&gt; mdy(\"12-03-2020\")\n2020-12-03\n\njulia&gt; mdy(\"1 24 2023\")\n2023-01-24\n\njulia&gt; mdy(\"01 24 2023\")\n2023-01-24\n\njulia&gt; mdy(missing)\nmissing\n\njulia&gt; mdy(\"F\u00c9VRIER 20 2020\") # French\n2020-02-20\n</code></pre> <p>source</p> <p># <code>TidierDates.mdy_h</code> \u2014 Method.</p> <pre><code>mdy_h(datetime_string::Union{AbstractString, Missing})::DateTime\n</code></pre> <p>Converts a date and time string in the format \"MM-DD-YYYY HH\" to a DateTime object.</p> <p>Arguments</p> <p><code>datetime_string</code>: A string containing a datetime representation (can contain missing values in a DataFrame).</p> <p>Returns</p> <p>A DateTime object constructed from the parsed month, day, year, and hour values from the input string, if all can be parsed successfully. Returns a missing value if the input is missing or if the datetime information cannot be parsed from the string.</p> <p>Examples</p> <pre><code>julia&gt; mdy_h(\"06-15-2023 09hr\")\n2023-06-15T09:00:00\n\njulia&gt; mdy_h(\"06-15-2023 09hr pM\")\n2023-06-15T21:00:00\n\njulia&gt; mdy_h(\"jan 3 2023 09hr p\")\n2023-01-03T21:00:00\n\njulia&gt; mdy_h(missing)\nmissing\n</code></pre> <p>source</p> <p># <code>TidierDates.mdy_hm</code> \u2014 Method.</p> <pre><code>mdy_hm(datetime_string::Union{AbstractString, Missing})::DateTime\n</code></pre> <p>Converts a date and time string in the format \"MM-DD-YYYY HH:MM\" to a DateTime object.</p> <p>Arguments</p> <p><code>datetime_string</code>: A string containing a datetime representation (can contain missing values in a DataFrame).</p> <p>Returns</p> <p>A DateTime object constructed from the parsed month, day, year, and hour values from the input string, if all can be parsed successfully. Returns a missing value if the input is missing or if the datetime information cannot be parsed from the string.</p> <p>Examples</p> <pre><code>julia&gt; mdy_hm(\"06-15-2023 09:03 P\")\n2023-06-15T21:03:00\n\njulia&gt; mdy_hm(\"june 15 2023 09:03 p\")\n2023-06-15T21:03:00\n\njulia&gt; mdy_hm(\"06-15-2023 09:03 \")\n2023-06-15T09:03:00\n\njulia&gt; mdy_hm(\"june 15 2023 09:03 p\")\n2023-06-15T21:03:00\n\njulia&gt; mdy_hm(missing)\nmissing\n</code></pre> <p>source</p> <p># <code>TidierDates.mdy_hms</code> \u2014 Method.</p> <pre><code>mdy_hms(datetime_string::Union{AbstractString, Missing})\n</code></pre> <p>Parses a datetime string that is expected to contain month, day, year, hour, minute, and second values.</p> <p>Arguments</p> <p><code>datetime_string</code>: A string containing a datetime representation (can contain missing values in a DataFrame).</p> <p>Returns</p> <p>A DateTime object constructed from the parsed month, day, year, hour, minute, and second values from the input string, if all can be parsed successfully. Returns a missing value if the input is missing or if the datetime information cannot be parsed from the string.</p> <p>Examples</p> <pre><code>julia&gt; mdy_hms(\"06/15/2023 08:30:15\")\n2023-06-15T08:30:15\n\njulia&gt; mdy_hms(\"06.15.2023.08.30.15\")\n2023-06-15T08:30:15\n\njulia&gt; mdy_hms(\"06.15.2023.08.30.15 pm\")\n2023-06-15T20:30:15\n\njulia&gt; mdy_hms(\"06152023083015\")\n2023-06-15T08:30:15\n\njulia&gt; mdy_hms(missing)\nmissing\n</code></pre> <p>source</p> <p># <code>TidierDates.now</code> \u2014 Function.</p> <pre><code>now(tzone::AbstractString=\"\")::ZonedDateTime\n</code></pre> <p>Get the current date and time in the specified time zone.</p> <p>Arguments</p> <p><code>tzone</code>: A string specifying the time zone to use. If not provided, the default time zone is used.</p> <p>Returns</p> <p>A ZonedDateTime object representing the current date and time in the specified time zone.</p> <p>source</p> <p># <code>TidierDates.pm</code> \u2014 Method.</p> <pre><code>pm(dt::DateTime)::Bool\n</code></pre> <p>Checks if the time is in the afternoon.</p> <p>Arguments</p> <p><code>dt</code>: A DateTime object</p> <p>Returns</p> <p>A boolean indicating whether the time is in the afternoon.</p> <p>Examples</p> <pre><code>julia&gt; pm(DateTime(2023, 6, 15, 9, 30, 0))\nfalse\n\njulia&gt; pm(DateTime(2023, 6, 15, 8, 30, 0))\nfalse\n</code></pre> <p>source</p> <p># <code>TidierDates.round_date</code> \u2014 Method.</p> <pre><code>round_date(dt::Union{DateTime, Date, Time, Missing}, unit::String)\n</code></pre> <p>Round a DateTime, Date, or Time object to the nearest specified unit.</p> <p>Arguments</p> <p><code>dt</code>: A DateTime, Date, or Time object (can contain missing values in a DataFrame). <code>unit</code>: A string specifying the units to use for rounding. The units can be one of the following: \"year\", \"quarter\", \"month\", \"day\", \"hour\", \"minute\", \"second\".</p> <p>Returns</p> <p>The DateTime, Date, or Time object rounded to the nearest specified unit. If the input is missing, the function returns a missing value.</p> <p>Examples</p> <pre><code>julia&gt; dt = DateTime(2023, 6, 15, 9, 45)\n2023-06-15T09:45:00\n\njulia&gt; round_date(dt, \"hour\")\n2023-06-15T10:00:00\n\njulia&gt; round_date(dt, \"day\")\n2023-06-15T00:00:00\n\njulia&gt; round_date(dt, \"quarter\")\n2023-07-01T00:00:00\n\njulia&gt; round_date(missing, \"day\")\nmissing\n</code></pre> <p>source</p> <p># <code>TidierDates.today</code> \u2014 Function.</p> <pre><code>today(tzone::AbstractString=\"\")::ZonedDateTime\n</code></pre> <p>Get the current date in the specified time zone.</p> <p>Arguments</p> <p><code>tzone</code>: A string specifying the time zone to use. If not provided, the default time zone is used.</p> <p>Returns</p> <p>A ZonedDateTime object representing the current date in the specified time zone.</p> <p>source</p> <p># <code>TidierDates.ymd</code> \u2014 Method.</p> <pre><code>ymd(date_string::Union{AbstractString, Missing})\n</code></pre> <p>Converts a date string in various formats (like \"yyyymmdd\", \"yyyy/mm/dd\", \"yyyy-mm-dd\", or \"year month day\") to a Julia Date object. The function is able to handle missing values and returns missing for missing inputs.</p> <p>Arguments</p> <p>date_string::Union{AbstractString, Missing}: The date string to be converted to a Date object.</p> <p>Examples</p> <pre><code>julia&gt; ymd(\"20201203\")\n2020-12-03\n\njulia&gt; ymd(\"2020/12/03\")\n2020-12-03\n\njulia&gt; ymd(\"2020-12-03\")\n2020-12-03\n\njulia&gt; ymd(\"2020 12 03\")\n2020-12-03\n\njulia&gt; ymd(\"2020 December 3rd\")\n2020-12-03\n\njulia&gt; ymd(missing)\nmissing\n</code></pre> <p>source</p> <p># <code>TidierDates.ymd_h</code> \u2014 Method.</p> <pre><code>ymd_h(datetime_string::Union{AbstractString, Missing})::DateTime\n</code></pre> <p>Converts a date and time string in the format \"YYYY-MM-DD HH\" to a DateTime object. </p> <p>Arguments</p> <p><code>datetime_string</code>: A string containing a datetime representation (can contain missing values in a DataFrame).</p> <p>Returns</p> <p>A DateTime object constructed from the parsed year, month, day, and hour values from the input string, if all can be parsed successfully. Returns a missing value if the input is missing or if the datetime information cannot be parsed from the string.</p> <p>Examples</p> <pre><code>julia&gt; ymd_h(\"2023-06-15 09hr\")\n2023-06-15T09:00:00\n\njulia&gt; ymd_h(\"2023-06-15 09hr p\")\n2023-06-15T21:00:00\n\njulia&gt; ymd_h(missing)\nmissing\n</code></pre> <p>source</p> <p># <code>TidierDates.ymd_hm</code> \u2014 Method.</p> <pre><code>ymd_hm(datetime_string::Union{AbstractString, Missing})::DateTime\n</code></pre> <p>Converts a date and time string in the format \"YYYY-MM-DD HH:MM\" to a DateTime object.</p> <p>Arguments</p> <p><code>datetime_string</code>: A string containing a datetime representation (can contain missing values in a DataFrame).</p> <p>Returns</p> <p>A DateTime object constructed from the parsed year, month, day, hour, and minute values from the input string, if all can be parsed successfully. Returns a missing value if the input is missing or if the datetime information cannot be parsed from the string.</p> <p>Examples</p> <pre><code>julia&gt; ymd_hm(\"2023-06-15 09:30\")\n2023-06-15T09:30:00\n\njulia&gt; ymd_hm(\"2023-06-15 09:30p\")\n2023-06-15T21:30:00\n\njulia&gt; ymd_hm(missing)\nmissing\n</code></pre> <p>source</p> <p># <code>TidierDates.ymd_hms</code> \u2014 Method.</p> <pre><code>ymd_hms(datetime_string::Union{AbstractString, Missing})\n</code></pre> <p>Convert a string with \"Year-Month-Day Hour:Minute:Second\" format to a DateTime object.</p> <p>Arguments</p> <p><code>datetime_string</code>: A string (can contain missing values in a DataFrame).</p> <p>Returns</p> <p>A DateTime object converted from the string. If the input is missing or the string format is incorrect, the function returns a missing value.</p> <p>Examples</p> <pre><code>julia&gt; ymd_hms(\"2023-06-15 09:30:00\")\n2023-06-15T09:30:00\n\njulia&gt; ymd_hms(\"2023/06/15 09:30:00\")\n2023-06-15T09:30:00\n\njulia&gt; ymd_hms(\"2023/06/15 09:30:00pm\")\n2023-06-15T21:30:00\n\njulia&gt; ymd_hms(\"2023 June 15 09:30:00am\")\n2023-06-15T09:30:00 \n\njulia&gt; ymd_hms(\"2023 June 15 09:30:00 P\")\n2023-06-15T21:30:00\n\njulia&gt; ymd_hms(missing)\nmissing\n</code></pre> <p>source</p> <p></p> <p></p>"},{"location":"reference/#reference-internal-functions","title":"Reference - Internal functions","text":""},{"location":"examples/generated/UserGuide/supported_functions/","title":"Supported Functions","text":"<pre><code>using TidierData\nusing TidierDates\n</code></pre>"},{"location":"examples/generated/UserGuide/supported_functions/#mdy-dmy-ymd","title":"<code>mdy()</code>, <code>dmy()</code>, <code>ymd()</code>","text":"<p>These functions parse dates represented as strings into a DateTime format in Julia. The input should be a string month-day-year, day-month-year, or year-month-day format respectively. They are relatively robust in their ability to take non-uniform strings of dates with year in yyyy format</p> <pre><code>df = DataFrame(date = [\"today is the 4th July, 2000\",\n                        \"ayer fue 13th Oct 2001\",\n                        \"3 of Mar, 2002 was a fun day\",\n                        \"23rd Apr 2003\",\n                        \"23/7/2043\",\n                        \"03/2/1932\",\n                        \"23-08-1932\",\n                        \"4th of July, 2005\",\n                        \"08092019\" ,\n                        missing])\n\n@chain df begin\n    @mutate(date = dmy(date))\nend\n</code></pre> 10\u00d71 DataFrame RowdateDate?12000-07-0422001-10-1332002-03-0342003-04-2352043-07-2361932-02-0371932-08-2382005-07-0492019-09-0810missing <p></p> <p></p>"},{"location":"examples/generated/UserGuide/supported_functions/#mdy_hms-dmy_hms-ymd_hms","title":"<code>mdy_hms()</code>, <code>dmy_hms()</code>, <code>ymd_hms()</code>","text":"<p>Similar to the previous group, these functions parse date-time strings in month-day-year, day-month-year, or year-month-day format respectively. The input should include both date and time information.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/supported_functions/#round_date-floor_date","title":"<code>round_date()</code>, <code>floor_date()</code>","text":"<pre><code>#`floor_date()`: This function rounds a date down to the nearest specified unit (e.g., hour, minute, day, month, year). It takes two arguments - a Date or DateTime object and a string indicating the unit of time to which the date should be floored.\n#`round_date()`: This function rounds a date to the nearest specified unit (e.g., hour, minute, month, year). Like\n\n\ndf2 = DataFrame(date = [\"20190330120141\", \"2008-04-05 16-23-07\", \"2010.06.07 19:45:00\",\n                        \"2011-2-8 14-3-7\", \"2012-3, 9 09:2, 37\", \"201305-15 0302-09\",\n                        \"2013 arbitrary 2 non-decimal 7 chars 13 in between 2 !!! 7\",\n                        \"OR collapsed formats: 20140618 181608 (as long as prefixed with zeros)\",\n                         missing ])\n\n@chain df2 begin\n    @mutate(date = ymd_hms(date))\n    @mutate(floor_byhr = floor_date(date, \"hour\"))\n    @mutate(round_bymin = round_date(date, \"minute\"))\n    @mutate(rounded_bymo = round_date(date, \"month\"))\nend\n</code></pre> 9\u00d74 DataFrame Rowdatefloor_byhrround_byminrounded_bymoDateTime?DateTime?DateTime?DateTime?1-166741088-11-01T09:06:23.360-166741088-11-01T09:00:00-166741088-11-01T09:06:00-166741088-11-01T00:00:0022008-04-05T16:23:072008-04-05T16:00:002008-04-05T16:23:002008-04-01T00:00:0032010-06-07T19:45:002010-06-07T19:00:002010-06-07T19:45:002010-06-01T00:00:0042011-02-08T14:03:072011-02-08T14:00:002011-02-08T14:03:002011-02-01T00:00:0052012-03-09T09:02:372012-03-09T09:00:002012-03-09T09:03:002012-03-01T00:00:0062013-05-15T03:02:092013-05-15T03:00:002013-05-15T03:02:002013-05-01T00:00:0072013-02-12T07:13:022013-02-12T07:00:002013-02-12T07:13:002013-02-01T00:00:0082014-06-18T18:16:082014-06-18T18:00:002014-06-18T18:16:002014-07-01T00:00:009missingmissingmissingmissing"},{"location":"examples/generated/UserGuide/supported_functions/#difftime","title":"<code>difftime()</code>","text":"<p>This function computes the difference between two DateTime or Date objects. It returns the result in the unit specified by the second argument, which can be \"seconds\", \"minutes\", \"hours\", \"days\", or \"weeks\". It returns this value as a float.</p> <pre><code>times = DataFrame(\n    start_time = [\n        \"06-27-2023 15:20:00\",\n        \"06-26-2023 12:45:15\",\n        \"06-26-2023 16:30:30\",\n        \"06-25-2023 10:11:35\",\n        \"06-24-2023 09:00:24\",\n        \"06-26-2023 09:30:00\",\n        \"06-25-2023 11:00:15\",\n        \"06-24-2023 01:34:45\",\n        \"06-26-2023 14:20:00\",\n        \"06-25-2023 10:45:30\"\n    ],\n    end_time = [\n        \"06-27-2023 14:53:53\",\n        \"06-25-2023 10:50:30\",\n        \"06-28-2023 16:32:30\",\n        \"06-24-2023 10:20:30\",\n        \"06-24-2023 10:05:00\",\n         missing,\n        \"10-25-2023 11:55:13\",\n        \"06-24-2023 11:35:45\",\n        \"07-26-2023 15:15:45\",\n        \"06-24-2023 12:50:15\"\n    ]\n)\n</code></pre> 10\u00d72 DataFrame Rowstart_timeend_timeStringString?106-27-2023 15:20:0006-27-2023 14:53:53206-26-2023 12:45:1506-25-2023 10:50:30306-26-2023 16:30:3006-28-2023 16:32:30406-25-2023 10:11:3506-24-2023 10:20:30506-24-2023 09:00:2406-24-2023 10:05:00606-26-2023 09:30:00missing706-25-2023 11:00:1510-25-2023 11:55:13806-24-2023 01:34:4506-24-2023 11:35:45906-26-2023 14:20:0007-26-2023 15:15:451006-25-2023 10:45:3006-24-2023 12:50:15 <p>After a string is converted into a datetime format, Date.jl functions such as hour(), year(), etc can be applied in Tidier chains as well.</p> <pre><code>@chain times begin\n    @mutate(start_time = mdy_hms(start_time))\n    @mutate(end_time = mdy_hms(end_time))\n    @mutate(timedifmins = difftime(end_time, start_time, \"minutes\"))\n    @mutate(timedifmins = difftime(end_time, start_time, \"hours\"))\n    @mutate(year= year(start_time))\n    @mutate(second = second(start_time))\nend\n</code></pre> 10\u00d75 DataFrame Rowstart_timeend_timetimedifminsyearsecondDateTimeDateTime?Float64?Int64Int6412023-06-27T15:20:002023-06-27T14:53:53-0.4352782023022023-06-26T12:45:152023-06-25T10:50:30-25.912520231532023-06-26T16:30:302023-06-28T16:32:3048.033320233042023-06-25T10:11:352023-06-24T10:20:30-23.851420233552023-06-24T09:00:242023-06-24T10:05:001.0766720232462023-06-26T09:30:00missingmissing2023072023-06-25T11:00:152023-10-25T11:55:132928.9220231582023-06-24T01:34:452023-06-24T11:35:4510.016720234592023-06-26T14:20:002023-07-26T15:15:45720.92920230102023-06-25T10:45:302023-06-24T12:50:15-21.9208202330 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/supported_functions/#hms","title":"<code>hms()</code>","text":"<p>This function parses time strings (e.g., \"12:34:56\") into a Time format in Julia. It takes a string or an array of strings with the time information and doesn't require additional arguments.</p> <pre><code>df3 = DataFrame(\n    Time = [\n        \"09:00:24\",\n        \"10:11:35\",\n        \"01:34:45\",\n        \"12:45:15\",\n        \"09:30:00\",\n        \"10:45:30\",\n        \"11:00:15\",\n        \"14:20:00\",\n        \"15:10:45\",\n        missing\n    ]\n)\n\n@chain df3 begin\n    @mutate(Time = hms(Time))\n    @filter(!ismissing(Time))\n    @mutate(hour = hour(Time))\nend\n</code></pre> 9\u00d72 DataFrame RowTimehourTime?Int64109:00:249210:11:3510301:34:451412:45:1512509:30:009610:45:3010711:00:1511814:20:0014915:10:4515 <p>This page was generated using Literate.jl.</p>"}]}